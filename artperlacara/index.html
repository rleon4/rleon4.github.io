<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>Art Geomètric Amb Expressió Facial</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.3/p5.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/ml5js/Intro-ML-Arts-IMA@ml5-build-10-7-19/ml5_build/ml5.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #333;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script>
    let faceapi;
    let video;
    let detections;

    const VIRTUAL_W = 640;
    const VIRTUAL_H = 480;

    // Opciones para face-api.js
    const detection_options = {
      withLandmarks: true,
      withDescriptors: false,
      minConfidence: 0.5
    };

    function setup() {
      createCanvas(VIRTUAL_W, VIRTUAL_H);
      video = createCapture(VIDEO);
      video.size(VIRTUAL_W, VIRTUAL_H);
      video.hide();

      faceapi = ml5.faceApi(video, detection_options, modelReady);
    }

    function modelReady() {
      console.log('Modelo listo!');
      faceapi.detect(gotResults);
    }

    function gotResults(err, result) {
      if (err) {
        console.error(err);
        return;
      }
      detections = result;
      faceapi.detect(gotResults); // Sigue detectando
    }

    function draw() {
      background(0); // Fondo negro

      if (detections) {
        if (detections.length > 0) {
          drawExpressionArt(detections[0].expressions);
        }
      }
    }

    function drawExpressionArt(expressions) {
      // Encuentra la emoción dominante
      let dominantEmotion = 'neutral';
      let maxConfidence = 0;
      let emotionConfidence = {};

      for (let emotion in expressions) {
        emotionConfidence[emotion] = expressions[emotion];
        if (expressions[emotion] > maxConfidence) {
          maxConfidence = expressions[emotion];
          dominantEmotion = emotion;
        }
      }

      let intensity = maxConfidence; // La confianza de la emoción dominante como intensidad

      noFill();
      strokeWeight(3); // Borde más fuerte

      switch (dominantEmotion) {
        case 'neutral':
          let neutralColor = color(150, 150, 150);
          stroke(neutralColor);
          fill(lerpColor(neutralColor, color(200, 200, 200), intensity)); // Centro más claro
          ellipse(VIRTUAL_W / 2 + random(-2 * intensity, 2 * intensity), VIRTUAL_H / 2 + random(-2 * intensity, 2 * intensity), 150 + random(-10 * intensity, 10 * intensity), 150 + random(-10 * intensity, 10 * intensity));
          break;

        case 'happy':
          let happyColor = color(255, 200, 0); // Amarillo cálido
          stroke(happyColor);
          fill(lerpColor(happyColor, color(255, 255, 100), intensity)); // Centro más claro, amarillo brillante
          beginShape();
          vertex(320 + random(-5 * intensity, 5 * intensity), 150 + random(-5 * intensity, 5 * intensity));
          vertex(370 + random(-5 * intensity, 5 * intensity), 180 + random(-5 * intensity, 5 * intensity));
          vertex(380 + random(-5 * intensity, 5 * intensity), 240 + random(-5 * intensity, 5 * intensity));
          vertex(360 + random(-5 * intensity, 5 * intensity), 290 + random(-5 * intensity, 5 * intensity));
          vertex(320 + random(-5 * intensity, 5 * intensity), 320 + random(-5 * intensity, 5 * intensity));
          vertex(280 + random(-5 * intensity, 5 * intensity), 290 + random(-5 * intensity, 5 * intensity));
          vertex(260 + random(-5 * intensity, 5 * intensity), 240 + random(-5 * intensity, 5 * intensity));
          vertex(270 + random(-5 * intensity, 5 * intensity), 180 + random(-5 * intensity, 5 * intensity));
          endShape(CLOSE);
          break;

        case 'sad':
          let sadColor = color(0, 0, 150); // Azul oscuro
          stroke(sadColor);
          fill(lerpColor(sadColor, color(100, 100, 255), intensity)); // Centro más claro, azul cielo
          beginShape();
          // Forma más "caída" o con esquinas hacia abajo
          vertex(VIRTUAL_W / 2 + random(-7 * intensity, 7 * intensity), VIRTUAL_H / 2 - 50 + random(-7 * intensity, 7 * intensity));
          vertex(VIRTUAL_W / 2 + 80 + random(-7 * intensity, 7 * intensity), VIRTUAL_H / 2 + random(-7 * intensity, 7 * intensity));
          vertex(VIRTUAL_W / 2 + 30 + random(-7 * intensity, 7 * intensity), VIRTUAL_H / 2 + 80 + random(-7 * intensity, 7 * intensity));
          vertex(VIRTUAL_W / 2 - 30 + random(-7 * intensity, 7 * intensity), VIRTUAL_H / 2 + 80 + random(-7 * intensity, 7 * intensity));
          vertex(VIRTUAL_W / 2 - 80 + random(-7 * intensity, 7 * intensity), VIRTUAL_H / 2 + random(-7 * intensity, 7 * intensity));
          endShape(CLOSE);
          break;

        case 'angry':
          let angryColor = color(150, 0, 0); // Rojo oscuro
          stroke(angryColor);
          fill(lerpColor(angryColor, color(255, 100, 100), intensity)); // Centro más claro, rojo brillante
          beginShape();
          // Forma angular y agresiva, puntas
          vertex(VIRTUAL_W / 2 + random(-10 * intensity, 10 * intensity), VIRTUAL_H / 2 - 70 + random(-10 * intensity, 10 * intensity));
          vertex(VIRTUAL_W / 2 + 70 + random(-10 * intensity, 10 * intensity), VIRTUAL_H / 2 - 30 + random(-10 * intensity, 10 * intensity));
          vertex(VIRTUAL_W / 2 + 60 + random(-10 * intensity, 10 * intensity), VIRTUAL_H / 2 + 70 + random(-10 * intensity, 10 * intensity));
          vertex(VIRTUAL_W / 2 + random(-10 * intensity, 10 * intensity), VIRTUAL_H / 2 + 90 + random(-10 * intensity, 10 * intensity));
          vertex(VIRTUAL_W / 2 - 60 + random(-10 * intensity, 10 * intensity), VIRTUAL_H / 2 + 70 + random(-10 * intensity, 10 * intensity));
          vertex(VIRTUAL_W / 2 - 70 + random(-10 * intensity, 10 * intensity), VIRTUAL_H / 2 - 30 + random(-10 * intensity, 10 * intensity));
          endShape(CLOSE);
          break;

        case 'fearful':
          let fearfulColor = color(70, 0, 70); // Morado oscuro
          stroke(fearfulColor);
          fill(lerpColor(fearfulColor, color(150, 50, 150), intensity)); // Centro más claro, morado claro
          beginShape();
          // Forma irregular, temblorosa
          for (let i = 0; i < 15; i++) {
            let angle = map(i, 0, 15, 0, TWO_PI);
            let r = 70 + random(-15 * intensity, 15 * intensity); // Mayor random para temblor
            let x = VIRTUAL_W / 2 + r * cos(angle) + random(-5 * intensity, 5 * intensity);
            let y = VIRTUAL_H / 2 + r * sin(angle) + random(-5 * intensity, 5 * intensity);
            vertex(x, y);
          }
          endShape(CLOSE);
          break;

        case 'disgusted':
          let disgustedColor = color(0, 100, 0); // Verde oscuro
          stroke(disgustedColor);
          fill(lerpColor(disgustedColor, color(100, 200, 100), intensity)); // Centro más claro, verde claro
          beginShape();
          // Forma irregular, contraída, como si se frunciera
          vertex(VIRTUAL_W / 2 + random(-8 * intensity, 8 * intensity), VIRTUAL_H / 2 - 40 + random(-8 * intensity, 8 * intensity));
          vertex(VIRTUAL_W / 2 + 60 + random(-8 * intensity, 8 * intensity), VIRTUAL_H / 2 + random(-8 * intensity, 8 * intensity));
          vertex(VIRTUAL_W / 2 + 20 + random(-8 * intensity, 8 * intensity), VIRTUAL_H / 2 + 50 + random(-8 * intensity, 8 * intensity));
          vertex(VIRTUAL_W / 2 - 20 + random(-8 * intensity, 8 * intensity), VIRTUAL_H / 2 + 50 + random(-8 * intensity, 8 * intensity));
          vertex(VIRTUAL_W / 2 - 60 + random(-8 * intensity, 8 * intensity), VIRTUAL_H / 2 + random(-8 * intensity, 8 * intensity));
          endShape(CLOSE);
          break;

        case 'surprised':
          let surprisedColor = color(0, 100, 100); // Cian/Aguamarina
          stroke(surprisedColor);
          fill(lerpColor(surprisedColor, color(100, 255, 255), intensity)); // Centro más claro, azul cielo brillante
          beginShape();
          // Forma abierta, como un círculo u óvalo
          vertex(VIRTUAL_W / 2 + random(-6 * intensity, 6 * intensity), VIRTUAL_H / 2 - 80 + random(-6 * intensity, 6 * intensity));
          vertex(VIRTUAL_W / 2 + 70 + random(-6 * intensity, 6 * intensity), VIRTUAL_H / 2 - 50 + random(-6 * intensity, 6 * intensity));
          vertex(VIRTUAL_W / 2 + 90 + random(-6 * intensity, 6 * intensity), VIRTUAL_H / 2 + random(-6 * intensity, 6 * intensity));
          vertex(VIRTUAL_W / 2 + 70 + random(-6 * intensity, 6 * intensity), VIRTUAL_H / 2 + 50 + random(-6 * intensity, 6 * intensity));
          vertex(VIRTUAL_W / 2 + random(-6 * intensity, 6 * intensity), VIRTUAL_H / 2 + 80 + random(-6 * intensity, 6 * intensity));
          vertex(VIRTUAL_W / 2 - 70 + random(-6 * intensity, 6 * intensity), VIRTUAL_H / 2 + 50 + random(-6 * intensity, 6 * intensity));
          vertex(VIRTUAL_W / 2 - 90 + random(-6 * intensity, 6 * intensity), VIRTUAL_H / 2 + random(-6 * intensity, 6 * intensity));
          vertex(VIRTUAL_W / 2 - 70 + random(-6 * intensity, 6 * intensity), VIRTUAL_H / 2 - 50 + random(-6 * intensity, 6 * intensity));
          endShape(CLOSE);
          break;

        default:
          // En caso de que no se detecte una emoción dominante o sea desconocida
          let defaultColor = color(150, 150, 150);
          stroke(defaultColor);
          fill(lerpColor(defaultColor, color(200, 200, 200), intensity));
          ellipse(VIRTUAL_W / 2 + random(-2, 2), VIRTUAL_H / 2 + random(-2, 2), 150 + random(-5, 5), 150 + random(-5, 5));
          break;
      }
    }
  </script>
</body>
</html>
